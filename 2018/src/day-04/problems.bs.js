// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Utils$Adventofcode2018 = require("./Utils.bs.js");
var Day4Data$Adventofcode2018 = require("./Day4Data.bs.js");

var input_data = Day4Data$Adventofcode2018.input.split("\n");

$$Array.sort((function (a, b) {
        var match = a < b;
        if (match) {
          return -1;
        } else {
          var match$1 = a > b;
          if (match$1) {
            return 1;
          } else {
            return 0;
          }
        }
      }), input_data);

function to_proof(str) {
  var match = Utils$Adventofcode2018.main_parser.exec(str);
  if (match !== null) {
    var date = Utils$Adventofcode2018.to_opt(Caml_array.caml_array_get(match, 1));
    var action_string = Utils$Adventofcode2018.to_opt(Caml_array.caml_array_get(match, 2));
    var timestamp = Utils$Adventofcode2018.parse_timestamp(date);
    var possible_action = Utils$Adventofcode2018.parse_action(action_string);
    var guard_id = possible_action !== /* StartShift */0 ? undefined : Utils$Adventofcode2018.parse_guard_id(action_string);
    if (guard_id !== undefined) {
      return /* ProofOfExistence */Block.__(1, [
                timestamp,
                possible_action,
                guard_id
              ]);
    } else {
      return /* ProofOfWork */Block.__(0, [
                timestamp,
                possible_action
              ]);
    }
  } else {
    throw [
          Utils$Adventofcode2018.Parse_error,
          "Unable to parse input"
        ];
  }
}

var $$Error = Caml_exceptions.create("Problems-Adventofcode2018.Error");

function soi(prim) {
  return String(prim);
}

var last_guard = /* record */[/* contents */-1];

function captains_log(acc, cur) {
  var proof = to_proof(cur);
  if (proof !== undefined) {
    var match = proof;
    if (match.tag) {
      var id = match[2];
      var match$1 = Js_dict.get(acc, String(id));
      if (match$1 === undefined) {
        acc[String(id)] = /* array */[];
      }
      last_guard[0] = id;
    } else {
      var match$2 = Js_dict.get(acc, String(last_guard[0]));
      var item;
      if (match$2 !== undefined) {
        item = match$2;
      } else {
        throw [
              $$Error,
              "Could not get last guard: " + String(last_guard[0])
            ];
      }
      acc[String(last_guard[0])] = $$Array.append(item, /* array */[match[0]]);
    }
  } else {
    throw [
          $$Error,
          "Could not parse proof"
        ];
  }
  return acc;
}

var guard_log = $$Array.fold_left(captains_log, { }, input_data);

function get_time_from_proof(proof) {
  if (proof !== undefined) {
    return proof[0] | 0;
  } else {
    return 0;
  }
}

function get_range(s, e) {
  return $$Array.mapi((function (idx, _n) {
                return s + idx | 0;
              }), Caml_array.caml_make_vect(e - s | 0, 0));
}

function get_minutes(ts) {
  return new Date(ts).getMinutes();
}

function nap_length(a, b) {
  return new Date(b).getMinutes() - new Date(a).getMinutes();
}

$$Array.iter((function (item) {
        var timestamps = item[1];
        var len = timestamps.length - 1 | 0;
        var nap_array = /* array */[];
        for(var ts_idx = 0; ts_idx <= len; ++ts_idx){
          if (ts_idx % 2 === 0) {
            var start_nap = new Date(Caml_array.caml_array_get(timestamps, ts_idx)).getMinutes() | 0;
            var end_nap = new Date(Caml_array.caml_array_get(timestamps, ts_idx + 1 | 0)).getMinutes() | 0;
            var nap_minutes = get_range(start_nap, end_nap);
            nap_array = $$Array.append(nap_array, nap_minutes);
          }
          
        }
        guard_log[item[0]] = nap_array;
        return /* () */0;
      }), Js_dict.entries(guard_log));

var most_minutes = $$Array.fold_left((function (param, param$1) {
        var minutes = param$1[1];
        var longest_nap = param[1];
        var match = minutes.length > longest_nap;
        if (match) {
          return /* tuple */[
                  param$1[0],
                  minutes.length
                ];
        } else {
          return /* tuple */[
                  param[0],
                  longest_nap
                ];
        }
      }), /* tuple */[
      "",
      0
    ], Js_dict.entries(guard_log));

var sleepiest_guard = most_minutes[0];

var match = Js_dict.get(guard_log, sleepiest_guard);

var nap_times;

if (match !== undefined) {
  nap_times = match;
} else {
  throw [
        $$Error,
        "Could not fetch guard"
      ];
}

function get_minute_count(param, param$1) {
  return $$Array.fold_left((function (map, cur) {
                var match = Js_dict.get(map, Pervasives.string_of_float(cur));
                if (match !== undefined) {
                  map[Pervasives.string_of_float(cur)] = match + 1 | 0;
                } else {
                  map[Pervasives.string_of_float(cur)] = 1;
                }
                return map;
              }), param, param$1);
}

var partial_arg = /* tuple */[
  "",
  0
];

function find_sleepiest_minute(param) {
  return $$Array.fold_left((function (param, param$1) {
                var cur_count = param$1[1];
                var acc_count = param[1];
                var match = cur_count > acc_count;
                if (match) {
                  return /* tuple */[
                          param$1[0],
                          cur_count
                        ];
                } else {
                  return /* tuple */[
                          param[0],
                          acc_count
                        ];
                }
              }), partial_arg, param);
}

var sleepiest_minute = find_sleepiest_minute(Js_dict.entries(get_minute_count({ }, nap_times)));

var minute_id = sleepiest_minute[0];

console.log("Puzzle 1:");

console.log(Caml_int32.imul(Caml_format.caml_int_of_string(most_minutes[0]), Caml_format.caml_float_of_string(minute_id) | 0));

console.log("");

function find_sleepies(a) {
  $$Array.sort((function (param, param$1) {
          var b_cnt = param$1[1];
          var a_cnt = param[1];
          var match = a_cnt === b_cnt;
          if (match) {
            return 0;
          } else {
            var match$1 = Caml_obj.caml_greaterthan(a_cnt, b_cnt);
            if (match$1) {
              return 1;
            } else {
              return -1;
            }
          }
        }), a);
  return Caml_array.caml_array_get(a, a.length - 1 | 0);
}

var p2 = $$Array.fold_left((function (acc, cur) {
        var minutes = cur[1];
        if (minutes.length === 0) {
          return acc;
        } else {
          var min_count = get_minute_count({ }, minutes);
          var most_likely_asleep = find_sleepies(Js_dict.entries(min_count));
          var cur_count = most_likely_asleep[1];
          if (cur_count > acc[2]) {
            return /* tuple */[
                    cur[0],
                    most_likely_asleep[0],
                    cur_count
                  ];
          } else {
            return acc;
          }
        }
      }), /* tuple */[
      "",
      "",
      0
    ], Js_dict.entries(guard_log));

var cur_min = p2[1];

var guard_id = p2[0];

console.log("Puzzle 2:");

console.log(Caml_format.caml_float_of_string(guard_id) * Caml_format.caml_float_of_string(cur_min));

exports.input_data = input_data;
exports.to_proof = to_proof;
exports.$$Error = $$Error;
exports.soi = soi;
exports.last_guard = last_guard;
exports.captains_log = captains_log;
exports.guard_log = guard_log;
exports.get_time_from_proof = get_time_from_proof;
exports.get_range = get_range;
exports.get_minutes = get_minutes;
exports.nap_length = nap_length;
exports.most_minutes = most_minutes;
exports.sleepiest_guard = sleepiest_guard;
exports.nap_times = nap_times;
exports.get_minute_count = get_minute_count;
exports.find_sleepiest_minute = find_sleepiest_minute;
exports.sleepiest_minute = sleepiest_minute;
exports.minute_id = minute_id;
exports.find_sleepies = find_sleepies;
exports.p2 = p2;
exports.guard_id = guard_id;
exports.cur_min = cur_min;
/* input_data Not a pure module */
